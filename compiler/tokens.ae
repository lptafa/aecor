
struct Location {
    filename: string
    line: i32
    col: i32
}

def Location::make(filename: string, line: i32, col: i32): Location {
    let loc: Location
    loc.filename = filename
    loc.line = line
    loc.col = col
    return loc
}

def Location::str(this): string {
    return `{.filename}:{.line}:{.col}`
}

struct Span {
    start: Location
    end: Location
}

def Span::make(start: Location, end: Location): Span {
    let span: Span
    span.start = start
    span.end = end
    return span
}

def Span::str(this): string {
    return `{.start.str()} => {.end.str()}`
}

// Needs to be called in the correct order!
def Span::join(this, other: Span): Span {
    let span: Span
    span.start = this.start
    span.end = other.end
    return span
}

struct Token {
    type: TokenType
    span: Span
    text: string
    seen_newline: bool
}

def Token::new(type: TokenType, span: Span, text: string): &Token {
    let tok = calloc(1, sizeof(Token)) as &Token
    tok.type = type
    tok.span = span
    tok.text = text
    tok.seen_newline = false
    return tok
}

def Token::from_type(type: TokenType, span: Span): &Token {
    return Token::new(type, span, "")
}

def Token::from_ident(text: string, span: Span): &Token {
    let type = TokenType::from_text(text)
    return Token::new(type, span, text)
}

def Token::str(&this): string {
    return `{.span.str()}: {.type.str()}`
}

enum TokenType {
  // Keywords
  And
  As
  Bool
  Break
  Char
  Continue
  Def
  Defer
  Else
  Enum
  Extern
  False
  F32
  For
  Fn
  I32
  If
  Let
  Match
  Null
  Not
  Or
  Return
  SizeOf
  String
  Struct
  True
  U8
  UntypedPtr
  Union
  Use
  Void
  Yield
  While

  // Other tokens
  AtSign
  Ampersand
  Backtick
  Caret
  CloseCurly
  CloseParen
  CloseSquare
  Colon
  ColonColon
  Comma
  Dot
  EOF
  Equals
  EqualEquals
  Exclamation
  FatArrow
  FloatLiteral
  FormatStringLiteral
  GreaterThan
  GreaterThanEquals
  Identifier
  IntLiteral
  LessThan
  LessThanEquals
  Line
  Minus
  MinusEquals
  NotEquals
  OpenCurly
  OpenParen
  OpenSquare
  Percent
  Plus
  PlusEquals
  Question
  Semicolon
  Slash
  SlashEquals
  Star
  StarEquals
  StringLiteral
  CharLiteral
}

def TokenType::from_text(text: string): TokenType {
    match text {
        "and" => return TokenType::And
        "as" => return TokenType::As
        "bool" => return TokenType::Bool
        "break" => return TokenType::Break
        "char" => return TokenType::Char
        "continue" => return TokenType::Continue
        "def" => return TokenType::Def
        "defer" => return TokenType::Defer
        "else" => return TokenType::Else
        "enum" => return TokenType::Enum
        "extern" => return TokenType::Extern
        "false" => return TokenType::False
        "f32" => return TokenType::F32
        "for" => return TokenType::For
        "fn" => return TokenType::Fn
        "i32" => return TokenType::I32
        "if" => return TokenType::If
        "let" => return TokenType::Let
        "match" => return TokenType::Match
        "not" => return TokenType::Not
        "null" => return TokenType::Null
        "or" => return TokenType::Or
        "return" => return TokenType::Return
        "sizeof" => return TokenType::SizeOf
        "string" => return TokenType::String
        "struct" => return TokenType::Struct
        "true" => return TokenType::True
        "u8" => return TokenType::U8
        "untyped_ptr" => return TokenType::UntypedPtr
        "union" => return TokenType::Union
        "use" => return TokenType::Use
        "void" => return TokenType::Void
        "yield" => return TokenType::Yield
        "while" => return TokenType::While
        else => return TokenType::Identifier
    }
}

def TokenType::str(this): string {
    match this {
        // Keywords
        TokenType::And => return "and"
        TokenType::As => return "as"
        TokenType::Bool => return "bool"
        TokenType::Break => return "break"
        TokenType::Char => return "char"
        TokenType::Continue => return "continue"
        TokenType::Def => return "def"
        TokenType::Defer => return "defer"
        TokenType::Else => return "else"
        TokenType::Enum => return "enum"
        TokenType::Extern => return "extern"
        TokenType::False => return "false"
        TokenType::F32 => return "f32"
        TokenType::For => return "for"
        TokenType::Fn => return "fn"
        TokenType::I32 => return "i32"
        TokenType::If => return "if"
        TokenType::Let => return "let"
        TokenType::Match => return "match"
        TokenType::Not => return "not"
        TokenType::Null => return "null"
        TokenType::Or => return "or"
        TokenType::Return => return "return"
        TokenType::SizeOf => return "sizeof"
        TokenType::String => return "string"
        TokenType::Struct => return "struct"
        TokenType::True => return "true"
        TokenType::U8 => return "u8"
        TokenType::UntypedPtr => return "untyped_ptr"
        TokenType::Union => return "union"
        TokenType::Use => return "use"
        TokenType::Void => return "void"
        TokenType::Yield => return "yield"
        TokenType::While => return "while"

        // Others
        TokenType::AtSign => return "AtSign"
        TokenType::Ampersand => return "Ampersand"
        TokenType::Backtick => return "Backtick"
        TokenType::Caret => return "Caret"
        TokenType::CloseCurly => return "CloseCurly"
        TokenType::CloseParen => return "CloseParen"
        TokenType::CloseSquare => return "CloseSquare"
        TokenType::Colon => return "Colon"
        TokenType::ColonColon => return "ColonColon"
        TokenType::Comma => return "Comma"
        TokenType::Dot => return "Dot"
        TokenType::EOF => return "EOF"
        TokenType::Equals => return "Equals"
        TokenType::EqualEquals => return "EqualEquals"
        TokenType::Exclamation => return "Exclamation"
        TokenType::FatArrow => return "FatArrow"
        TokenType::FloatLiteral => return "FloatLiteral"
        TokenType::FormatStringLiteral => return "FormatStringLiteral"
        TokenType::GreaterThan => return "GreaterThan"
        TokenType::GreaterThanEquals => return "GreaterThanEquals"
        TokenType::Identifier => return "Identifier"
        TokenType::IntLiteral => return "IntLiteral"
        TokenType::LessThan => return "LessThan"
        TokenType::LessThanEquals => return "LessThanEquals"
        TokenType::Line => return "Line"
        TokenType::Minus => return "Minus"
        TokenType::MinusEquals => return "MinusEquals"
        TokenType::NotEquals => return "NotEquals"
        TokenType::OpenCurly => return "OpenCurly"
        TokenType::OpenParen => return "OpenParen"
        TokenType::OpenSquare => return "OpenSquare"
        TokenType::Percent => return "Percent"
        TokenType::Plus => return "Plus"
        TokenType::PlusEquals => return "PlusEquals"
        TokenType::Question => return "Question"
        TokenType::Semicolon => return "Semicolon"
        TokenType::Slash => return "Slash"
        TokenType::SlashEquals => return "SlashEquals"
        TokenType::Star => return "Star"
        TokenType::StarEquals => return "StarEquals"
        TokenType::StringLiteral => return "StringLiteral"
        TokenType::CharLiteral => return "CharLiteral"
    }
}
