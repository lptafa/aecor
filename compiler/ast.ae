use "lib/vector.ae"
use "lib/map.ae"
use "@/types.ae"

enum ASTType {
  Assignment
  Address
  And
  Block
  BoolLiteral
  BitwiseAnd
  BitwiseOr
  BitwiseXor
  Break
  Call
  Cast
  CharLiteral
  Continue
  Defer
  Dereference
  Divide
  DivideEquals
  EnumValue
  Equals
  FloatLiteral
  FormatStringLiteral
  For
  GreaterThan
  GreaterThanEquals
  If
  Identifier
  Index
  IntLiteral
  IsNotNull
  LessThan
  LessThanEquals
  Match
  Member
  Minus
  MinusEquals
  Modulus
  Multiply
  MultiplyEquals
  Not
  NotEquals
  Null
  Or
  Plus
  PlusEquals
  Return
  SizeOf
  ScopeLookup
  StringLiteral
  Ternary
  UnaryMinus
  VarDeclaration
  Yield
  While
}

def ASTType::str(this): string {
    match this {
        Assignment => return "Assignment"
        Address => return "Address"
        And => return "And"
        Block => return "Block"
        BoolLiteral => return "BoolLiteral"
        BitwiseAnd => return "BitwiseAnd"
        BitwiseOr => return "BitwiseOr"
        BitwiseXor => return "BitwiseXor"
        Break => return "Break"
        Call => return "Call"
        Cast => return "Cast"
        CharLiteral => return "CharLiteral"
        Continue => return "Continue"
        Defer => return "Defer"
        Dereference => return "Dereference"
        Divide => return "Divide"
        DivideEquals => return "DivideEquals"
        EnumValue => return "EnumValue"
        Equals => return "Equals"
        FloatLiteral => return "FloatLiteral"
        FormatStringLiteral => return "FormatStringLiteral"
        For => return "For"
        GreaterThan => return "GreaterThan"
        GreaterThanEquals => return "GreaterThanEquals"
        If => return "If"
        Identifier => return "Identifier"
        Index => return "Index"
        IntLiteral => return "IntLiteral"
        IsNotNull => return "IsNotNull"
        LessThan => return "LessThan"
        LessThanEquals => return "LessThanEquals"
        Match => return "Match"
        Member => return "Member"
        Minus => return "Minus"
        MinusEquals => return "MinusEquals"
        Modulus => return "Modulus"
        Multiply => return "Multiply"
        MultiplyEquals => return "MultiplyEquals"
        Not => return "Not"
        NotEquals => return "NotEquals"
        Null => return "Null"
        Or => return "Or"
        Plus => return "Plus"
        PlusEquals => return "PlusEquals"
        Return => return "Return"
        SizeOf => return "SizeOf"
        ScopeLookup => return "ScopeLookup"
        StringLiteral => return "StringLiteral"
        Ternary => return "Ternary"
        UnaryMinus => return "UnaryMinus"
        VarDeclaration => return "VarDeclaration"
        Yield => return "Yield"
        While =>    return "While"
    }
}

def ASTType::from_token(type: TokenType): ASTType {
    match type {
        Ampersand => return ASTType::BitwiseAnd
        And => return ASTType::And
        Caret => return ASTType::BitwiseXor
        EqualEquals => return ASTType::Equals
        Equals => return ASTType::Assignment
        GreaterThan => return ASTType::GreaterThan
        GreaterThanEquals => return ASTType::GreaterThanEquals
        LessThan => return ASTType::LessThan
        LessThanEquals => return ASTType::LessThanEquals
        Line => return ASTType::BitwiseOr
        Minus => return ASTType::Minus
        MinusEquals => return ASTType::MinusEquals
        NotEquals => return ASTType::NotEquals
        Or => return ASTType::Or
        Percent => return ASTType::Modulus
        Plus => return ASTType::Plus
        PlusEquals => return ASTType::PlusEquals
        Slash => return ASTType::Divide
        SlashEquals => return ASTType::DivideEquals
        Star => return ASTType::Multiply
        StarEquals => return ASTType::MultiplyEquals

        else => {
            println("Unhandled token type in ASTType::from_token: %s", type.str())
            exit(1)
        }
    }
}

struct Variable {
    name: string
    type: &Type
    span: Span

    is_extern: bool
    extern_name: string
}

def Variable::new(name: string, type: &Type, span: Span): &Variable {
    let var = calloc(1, sizeof(Variable)) as &Variable
    var.name = name
    var.type = type
    var.span = span
    return var
}

struct Function {
    name: string
    params: &Vector     // Vector<&Variable>
    return_type: &Type
    body: &AST
    exits: bool

    type: &Type
    span: Span

    is_extern: bool
    extern_name: string

    is_static: bool
    is_method: bool
    method_struct_name: string
}

def Function::new(span: Span): &Function {
    let func = calloc(1, sizeof(Function)) as &Function
    func.params = Vector::new()
    func.span = span
    return func
}

struct Structure {
  type: &Type
  name: string
  fields: &Vector     // Vector<&Variable>
  span: Span

  is_extern: bool
  extern_name: string

  is_enum: bool
  is_union: bool
}

def Structure::new(span: Span): &Structure {
    let struc = calloc(1, sizeof(Structure)) as &Structure
    struc.fields = Vector::new()
    struc.span = span
    return struc
}

def Structure::find_field(&this, name: string): &Variable {
    for let i = 0; i < .fields.size; i += 1 {
        let field = .fields.at(i) as &Variable
        if field.name.eq(name) {
            return field
        }
    }
    return null
}

struct Program {
    functions: &Vector    // Vector<&Function>
    structures: &Vector   // Vector<&Structure>
    global_vars: &Vector  // Vector<&AST>
    span: Span

    included_files: &Map  // Map<string, string>

    c_flags: &Vector           // Vector<string>
    c_includes: &Vector        // Vector<string>
    c_embed_headers: &Vector   // Vector<string>
}

def Program::new(): &Program {
    let prog = calloc(1, sizeof(Program)) as &Program
    prog.functions = Vector::new()
    prog.structures = Vector::new()
    prog.global_vars = Vector::new()

    prog.included_files = Map::new()

    prog.c_flags = Vector::new()
    prog.c_includes = Vector::new()
    prog.c_embed_headers = Vector::new()
    return prog
}

def Program::is_file_included(&this, filename: string): bool {
    let len = filename.len()
    if len > 2 and filename[0] == '.' and filename[1] == '/' {
        filename = &filename[2]
    }
    return this.included_files.exists(filename)
}

def Program::add_included_file(&this, filename: string) {
    let len = filename.len()
    if len > 2 and filename[0] == '.' and filename[1] == '/' {
        filename = &filename[2]
    }
    .included_files.insert(filename, filename)
}

struct Block {
    statements: &Vector     // Vector<&AST>
}

struct Binary {
    lhs: &AST
    rhs: &AST
}

struct Identifier {
    name: string
    var: &Variable
    is_function: bool
    func: &Function
}

struct FormatString {
    str: string
    parts: &Vector    // Vector<string>
    exprs: &Vector    // Vector<&AST>
}

struct FuncCall {
    callee: &AST
    args: &Vector    // Vector<&AST>
    func: &Function
    added_method_arg: bool
}

struct Member {
    lhs: &AST
    name: string
    is_method: bool
    is_pointer: bool
}

struct EnumValue {
    struct_def: &Structure
    name: string
}

struct VarDeclaration {
    var: &Variable
    init: &AST
}

struct IfStatement {
    cond: &AST
    body: &AST
    els: &AST
}

struct Loop {
    init: &AST
    cond: &AST
    incr: &AST
    body: &AST
}

struct Cast {
    lhs: &AST
    to: &Type
}

struct MatchCase {
    cond: &AST
    body: &AST
}

def MatchCase::new(cond: &AST, body: &AST): &MatchCase {
    let _case = calloc(1, sizeof(MatchCase)) as &MatchCase
    _case.cond = cond
    _case.body = body
    return _case
}

struct Match {
    expr: &AST
    cases: &Vector  // Vector<&MatchCase>
    defolt: &AST
    defolt_span: Span
}

union ASTUnion {
    block: Block
    binary: Binary
    ident: Identifier
    fmt_str: FormatString
    call: FuncCall
    member: Member
    enum_val: EnumValue
    var_decl: VarDeclaration
    if_stmt: IfStatement
    loop: Loop
    cast: Cast
    unary: &AST
    match_stmt: Match
    num_literal: string
    bool_literal: bool
    string_literal: string
    char_literal: string
    size_of_type: &Type
}

struct AST {
    type: ASTType
    span: Span
    u: ASTUnion
    etype: &Type
    returns: bool
}

def AST::new(type: ASTType, span: Span): &AST {
    let ast = calloc(1, sizeof(AST)) as &AST
    ast.type = type
    ast.span = span
    return ast
}

def AST::new_unop(type: ASTType, span: Span, expr: &AST): &AST {
    let ast = AST::new(type, span)
    ast.u.unary = expr
    return ast
}

def AST::new_binop(type: ASTType, lhs: &AST, rhs: &AST): &AST {
    let ast = AST::new(type, lhs.span.join(rhs.span))
    ast.u.binary.lhs = lhs
    ast.u.binary.rhs = rhs
    return ast
}

def AST::callee_is(&this, expected: string): bool {
    if not this? return false
    if .type != ASTType::Call return false
    if .u.call.callee.type != ASTType::Identifier return false
    let name = .u.call.callee.u.ident.name
    return name.eq(expected)
}
